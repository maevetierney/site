 <!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>About Landing</title>
<style id="applicationStylesheet" type="text/css">
        .mediaViewInfo {
                --web-view-name: About Landing;
                --web-view-id: About_Landing;
                --web-scale-on-resize: true;
                --web-enable-deep-linking: true;
}
:root {
} *{
--web-view-ids: About_Landing;
margin: 0;
padding: 0;
box-sizing: border-box;
border: none;
}
#About_Landing {
        position: absolute;
        width: 1920px;
        height: 1077px;
        background-color: rgba(255,255,255,1);
        overflow: hidden;
        --web-view-name: About Landing;
        --web-view-id: About_Landing;
        --web-scale-on-resize: true;
        --web-enable-deep-linking: true;
}
@keyframes fadein {
0% {
                opacity: 0;
        100% {
}
}
opacity: 1;
}
#I_am_passionate_about_making_b {
        left: 271px;
        top: 688px;
        position: absolute;
        overflow: visible;
        width: 792px;
        height: 193px;
        text-align: left;
        font-family: Roboto;
        font-style: normal;
        font-weight: normal;
        font-size: 22px;

        color: rgba(0,0,0,1);
}
#Group_8 {
        position: absolute;
        width: 1379px;
        height: 390px;
        left: 271px;
        top: 197px;
        overflow: visible;
}
#Rectangle_19 {
        fill: rgba(255,245,0,1);
}
.Rectangle_19 {
        position: absolute;
        overflow: visible;
        width: 795px;
        height: 45px;
        left: 584px;
        top: 334px;
}
#_Maeve__Tierney__UX_Engineer_w {
        left: 0px;
        top: 0px;
        position: absolute;
        overflow: visible;
        width: 1357px;
        white-space: nowrap;
        text-align: left;
        font-family: Helvetica Neue;
        font-style: normal;
        font-weight: normal;
        font-size: 16px;
        color: rgba(0,0,0,1);
}
#global_nav_-_about {
        position: absolute;
        width: 1920px;
        height: 156px;
        left: 0px;
        top: 0px;
        overflow: visible;
}
#Rectangle_35 {
        fill: rgba(255,255,255,1);
}
.Rectangle_35 {
        position: absolute;
        overflow: visible;
        width: 1920px;
        height: 156px;
        left: 0px;
top: 0px;
}
#Group_89 {
        position: absolute;
        width: 573px;
 
        height: 26px;
        left: 140px;
        top: 65px;
        overflow: visible;
}
#Group_10 {
        position: absolute;
        width: 573px;
        height: 26px;
        left: 0px;
        top: 0px;
        overflow: visible;
}
#Group_9 {
        position: absolute;
        width: 573px;
        height: 26px;
        left: 0px;
        top: 0px;
        overflow: visible;
}
#Group_3 {
        position: absolute;
        width: 573px;
        height: 26px;
        left: 0px;
        top: 0px;
        overflow: visible;
}
#About {
        left: 0px;
        top: 0px;
        position: absolute;
        overflow: visible;
        width: 55px;
        white-space: nowrap;
        text-align: left;
        font-family: Roboto;
        font-style: normal;
        font-weight: bold;
        font-size: 20px;
        color: rgba(0,0,0,1);
}
#Contact_Me {
        left: 471px;
        top: 0px;
        position: absolute;
        overflow: visible;
        width: 103px;
        white-space: nowrap;
        --web-animation: fadein 0.3s ease-out;
        --web-action-type: page;
        --web-action-target: Contact_Me1.html;
        cursor: pointer;
        text-align: left;
        font-family: Roboto;
        font-style: normal;
 
        font-weight: lighter;
        font-size: 20px;
        color: rgba(0,0,0,1);
}
#Work {
 left: 326px;
top: 0px;
position: absolute;
overflow: visible;
width: 46px;
white-space: nowrap;
--web-animation: fadein 0.3s ease-out;
--web-action-type: page;
--web-action-target: Work_Page.html;
cursor: pointer;
text-align: left;
font-family: Roboto;
font-style: normal;
font-weight: lighter;
font-size: 20px;
color: rgba(0,0,0,1);
}
#Resume {
        left: 153px;
        top: 0px;
        position: absolute;
        overflow: visible;
        width: 73px;
        white-space: nowrap;
        --web-animation: fadein 0.3s ease-out;
        --web-action-type: page;
        --web-action-target: Resume_.html;
        cursor: pointer;
        text-align: left;
        font-family: Roboto;
        font-style: normal;
        font-weight: lighter;
        font-size: 20px;
        color: rgba(0,0,0,1);
}
#Group_13 {
        position: absolute;
        width: 30px;
        height: 141px;
        left: 142px;
        top: 469px;
        overflow: visible;
}
#Group_6 {
        position: absolute;
        width: 30px;
        height: 141px;
        left: 0px;
        top: 0px;
        overflow: visible;
}
#Icon_feather-linkedin {

        position: absolute;
        width: 30px;
        height: 28.5px;
        left: 0px;
        top: 0px;
        overflow: visible;
}
#Path_3 {
        fill: transparent;
        stroke: rgba(0,0,0,1);
        stroke-width: 1.5px;
        stroke-linejoin: round;
        stroke-linecap: round;
        stroke-miterlimit: 4;
        shape-rendering: auto;
}
.Path_3 {
        overflow: visible;
        position: absolute;
        width: 19.5px;
        height: 21px;
        left: 12px;
        top: 9px;
        transform: matrix(1,0,0,1,0,0);
}
#Path_4 {
        fill: transparent;
        stroke: rgba(0,0,0,1);
        stroke-width: 1.5px;
        stroke-linejoin: round;
        stroke-linecap: round;
        stroke-miterlimit: 4;
        shape-rendering: auto;
}
.Path_4 {
        overflow: visible;
        position: absolute;
        width: 7.5px;
        height: 19.5px;
        left: 0px;
        top: 10.5px;
        transform: matrix(1,0,0,1,0,0);
}
#Path_5 {
        fill: transparent;
        stroke: rgba(0,0,0,1);
        stroke-width: 1.5px;
        stroke-linejoin: round;
        stroke-linecap: round;
        stroke-miterlimit: 4;
        shape-rendering: auto;
}
.Path_5 {
        overflow: visible;
        position: absolute;
        width: 7.5px;
        height: 7.5px;
 
        left: 0px;
        top: 0px;
        transform: matrix(1,0,0,1,0,0);
}
#Icon_feather-mail {
        position: absolute;
        width: 30px;
        height: 24px;
        left: 0px;
        top: 59.25px;
        overflow: visible;
}
#Path_6 {
        fill: transparent;
        stroke: rgba(0,0,0,1);
        stroke-width: 1.5px;
        stroke-linejoin: round;
        stroke-linecap: round;
        stroke-miterlimit: 4;
        shape-rendering: auto;
}
.Path_6 {
        overflow: visible;
        position: absolute;
        width: 31.5px;
        height: 25.5px;
        left: 0px;
        top: 0px;
        transform: matrix(1,0,0,1,0,0);
}
#Path_7 {
        fill: transparent;
        stroke: rgba(0,0,0,1);
        stroke-width: 1.5px;
        stroke-linejoin: round;
        stroke-linecap: round;
        stroke-miterlimit: 4;
        shape-rendering: auto;
}
.Path_7 {
        overflow: visible;
        position: absolute;
        width: 32.089px;
        height: 12.295px;
        left: 0px;
        top: 3px;
        transform: matrix(1,0,0,1,0,0);
}
#Icon_feather-download {
        position: absolute;
        width: 27px;
        height: 27px;
        left: 2px;
        top: 114px;
        overflow: visible;
}
#Path_8 {
 
} </style>
overflow: visible;
position: absolute;
width: 1.5px;
height: 19.5px;
left: 13.5px;
top: 0px;
transform: matrix(1,0,0,1,0,0);
        fill: transparent;
        stroke: rgba(0,0,0,1);
        stroke-width: 1.5px;
        stroke-linejoin: round;
        stroke-linecap: round;
        stroke-miterlimit: 4;
        shape-rendering: auto;
}
.Path_8 {
        overflow: visible;
        position: absolute;
        width: 28.5px;
        height: 10.5px;
        left: 0px;
        top: 18px;
        transform: matrix(1,0,0,1,0,0);
}
#Path_9 {
        fill: transparent;
        stroke: rgba(0,0,0,1);
        stroke-width: 1.5px;
        stroke-linejoin: round;
        stroke-linecap: round;
        stroke-miterlimit: 4;
        shape-rendering: auto;
}
.Path_9 {
        overflow: visible;
        position: absolute;
        width: 17.121px;
        height: 9.311px;
        left: 6px;
        top: 10.5px;
        transform: matrix(1,0,0,1,0,0);
}
#Path_10 {
        fill: transparent;
        stroke: rgba(0,0,0,1);
        stroke-width: 1.5px;
        stroke-linejoin: round;
        stroke-linecap: round;
        stroke-miterlimit: 4;
        shape-rendering: auto;
}
.Path_10 {
 <script id="applicationScript">
///////////////////////////////////////
// INITIALIZATION

///////////////////////////////////////
/**
 * Functionality for scaling, showing by media query, and navigation
between multiple pages on a single page.
 * Code subject to change.
 **/
if (window.console==null) { window["console"] = { log : function() {}
} }; // some browsers do not set console
var Application = function() {
        // event constants
        this.prefix = "--web-";
        this.NAVIGATION_CHANGE = "viewChange";
        this.VIEW_NOT_FOUND = "viewNotFound";
        this.VIEW_CHANGE = "viewChange";
        this.VIEW_CHANGING = "viewChanging";
        this.STATE_NOT_FOUND = "stateNotFound";
        this.APPLICATION_COMPLETE = "applicationComplete";
        this.APPLICATION_RESIZE = "applicationResize";
        this.SIZE_STATE_NAME = "data-is-view-scaled";
        this.STATE_NAME = this.prefix + "state";
        this.lastTrigger = null;
        this.lastView = null;
        this.lastState = null;
        this.lastOverlay = null;
        this.currentView = null;
        this.currentState = null;
        this.currentOverlay = null;
        this.currentQuery = {index: 0, rule: null, mediaText: null,
id: null};
        this.inclusionQuery = "(min-width: 0px)";
        this.exclusionQuery = "none and (min-width: 99999px)";
        this.LastModifiedDateLabelName = "LastModifiedDateLabel";
        this.viewScaleSliderId = "ViewScaleSliderInput";
        this.pageRefreshedName = "showPageRefreshedNotification";
        this.applicationStylesheet = null;
        this.mediaQueryDictionary = {};
        this.viewsDictionary = {};
        this.addedViews = [];
        this.views = {};
        this.viewIds = [];
        this.viewQueries = {};
        this.overlays = {};
        this.overlayIds = [];
        this.numberOfViews = 0;
        this.verticalPadding = 0;
        this.horizontalPadding = 0;
        this.stateName = null;
        this.viewScale = 1;
        this.viewLeft = 0;
        this.viewTop = 0;
        this.horizontalScrollbarsNeeded = false;
        this.verticalScrollbarsNeeded = false;
 
        // view settings
        this.showUpdateNotification = false;
        this.showNavigationControls = false;
        this.scaleViewsToFit = false;
        this.scaleToFitOnDoubleClick = false;
        this.actualSizeOnDoubleClick = false;
        this.scaleViewsOnResize = false;
        this.navigationOnKeypress = false;
        this.showViewName = false;
        this.enableDeepLinking = true;
        this.refreshPageForChanges = false;
        this.showRefreshNotifications = true;
        // view controls
        this.scaleViewSlider = null;
        this.lastModifiedLabel = null;
        this.supportsPopState = false; //
window.history.pushState!=null;
        this.initialized = false;
        // refresh properties
        this.refreshDuration = 250;
        this.lastModifiedDate = null;
        this.refreshRequest = null;
        this.refreshInterval = null;
        this.refreshContent = null;
        this.refreshContentSize = null;
        this.refreshCheckContent = false;
        this.refreshCheckContentSize = false;
        var self = this;
        self.initialize = function(event) {
                var view = self.getVisibleView();
                var views = self.getVisibleViews();
                if (view==null) view = self.getInitialView();
                self.collectViews();
                self.collectOverlays();
                self.collectMediaQueries();
 and again later
for (let index = 0; index < views.length; index++) {
        var view = views[index];
        self.setViewOptions(view);
        self.setViewVariables(view);
        self.centerView(view);
}
// sometimes the body size is 0 so we call this now
if (self.initialized) {
window.addEventListener(self.NAVIGATION_CHANGE,
self.viewChangeHandler);
self.keypressHandler);
self.keypressHandler);
window.addEventListener("keyup",
window.addEventListener("keypress",

                        window.addEventListener("resize",
self.resizeHandler);
self.doubleClickHandler);
                        if (self.supportsPopState) {
                                window.addEventListener('popstate',
self.popStateHandler);
                        }
else {
self.hashChangeHandler);
                        }
 view);
if (self.scaleViewsToFit) {
        self.viewScale = self.scaleViewToFit(view);
        if (self.viewScale<0) {
                setTimeout(self.scaleViewToFit, 500,
} }
else if (view) {
        self.viewScale = self.getViewScaleValue(view);
        self.centerView(view);
        self.updateSliderValue(self.viewScale);
}
else {
        // no view found
if (self.showUpdateNotification) {
}
}
}
self.showNotification();
window.document.addEventListener("dblclick",
                        // we are ready to go
                        window.dispatchEvent(new
Event(self.APPLICATION_COMPLETE));
}
}
                //"addEventListener" in window ? null :
window.addEventListener = window.attachEvent;
                //"addEventListener" in document ? null :
document.addEventListener = document.attachEvent;
}
window.addEventListener('hashchange',
}
if (self.initialized==false) {
        if (self.enableDeepLinking) {
                self.syncronizeViewToURL();
        if (self.refreshPageForChanges) {
                self.setupRefreshForChanges();
        self.initialized = true;

 true);
"text";
self.refreshContent =
self.refreshRequest.open('GET', url,
self.refreshRequest.responseType =
///////////////////////////////////////
// AUTO REFRESH
///////////////////////////////////////
self.setupRefreshForChanges = function() {
        self.refreshRequest = new XMLHttpRequest();
        if (!self.refreshRequest) {
}
// get document start values immediately
self.requestRefreshUpdate();
first call to compare to later
// get page last modified date for the
if (self.lastModifiedDate==null) {
}
return false;
        /**
         * Attempt to check the last modified date by the headers
         * or the last modified property from the byte array
(experimental)
         **/
        self.requestRefreshUpdate = function() {
                var url = document.location.href;
                var protocol = window.location.protocol;
                var method;
try {
true);
document.documentElement.outerHTML;
headers in FF so get blob if possible
// File system does not send
if (self.refreshCheckContentSize) {
        self.refreshRequest.open('HEAD', url,
}
else if (self.refreshCheckContent) {
}
else {
                                        if (protocol=="file:") {
self.refreshRequest.open("GET", url, true);
self.refreshRequest.responseType = "blob";
                                        }
else {

self.refreshRequest.open("HEAD", url, true);
self.refreshRequest.responseType = "blob";
                                        }
                                        self.refreshRequest.onload =
 self.refreshOnLoadOnceHandler;
Safari) this error occurs at send:
XMLHttpRequest at 'file:///index.html' from origin 'null'
                                        // has been blocked by CORS
                                        // Cross origin requests are
                                        // http, data, chrome, chrome-
//
                                        // Safari - XMLHttpRequest
cannot load file:///Users/user/Public/index.html. Cross origin
requests are only supported for HTTP.
                                        //
                                        // Solution is to run a local
server, set local permissions or test in another browser
policy:
only supported for protocol schemes:
extension, https.
self.refreshRequest.send(null);
following behavior occurs possibly due to an AJAX call to check last
modified date:
page disabled back and forward caching.
//
// DOM7011: The code on this
// In Brave (Chrome) error
when on the server
https://www.example.com/ net::ERR_INSUFFICIENT_RESOURCES
self.refreshRequest.send(null);
// index.js:221 HEAD
//
}
else {
                                        self.refreshRequest = new
self.refreshRequest.onreadystatechange = self.refreshHandler;
XMLHttpRequest();
= function() {
find page to check for updates");
self.refreshRequest.ontimeout
        self.log("Couldn't
}
var method;
if (protocol=="file:") {
// In some browsers (Chrome &
//
// Chrome - Access to
// In MS browsers the

                                                method = "GET";
                                        else {
                                                method = "HEAD";
                                        //refreshRequest.open('HEAD',
url, true);
self.refreshRequest.open(method, url, true);
self.refreshRequest.responseType = "blob";
self.refreshRequest.send(null);
 reason:")
} }
self.log("Refresh failed for the following
self.log(error);
} }
}
catch (error) {
self.refreshHandler = function() {
        var contentSize;
        try {
                if (self.refreshRequest.readyState ===
XMLHttpRequest.DONE) {
|| 200) {
self.updateLastModifiedLabel();
(self.refreshCheckContentSize) {
}
}
if (self.refreshRequest.status === 2
        self.refreshRequest.status ===
        var pageChanged = false;
if
                                                var lastModifiedHeader
= self.refreshRequest.getResponseHeader("Last-Modified");
                                                contentSize =
self.refreshRequest.getResponseHeader("Content-Length");
                                                //lastModifiedDate =
refreshRequest.getResponseHeader("Last-Modified");
self.refreshRequest.getAllResponseHeaders();
headers.indexOf("Content-Length")!=-1;
{
var headers =
var hasContentHeader =
if (hasContentHeader)
        contentSize =

self.refreshRequest.getResponseHeader("Content-Length");
 not been set yet
(self.refreshContentSize==null) {
self.refreshContentSize = contentSize;
exit and let interval call this method again
return;
(contentSize!=self.refreshContentSize) {
pageChanged = true;
// size has if
//
}
else if
(self.refreshCheckContent) {
(self.refreshRequest.responseText!=self.refreshContent) {
true;
if
} }
else {
pageChanged =
self.getLastModified(self.refreshRequest);
lastModifiedHeader =
                                                if
(self.lastModifiedDate!=lastModifiedHeader) {
self.log("lastModifiedDate:" + self.lastModifiedDate +
",lastModifiedHeader:" +lastModifiedHeader);
pageChanged =
true;
clearInterval(self.refreshInterval);
self.refreshUpdatedPage();
}
else {
} }
} if
} }
if (pageChanged) {
return; }
self.log('There was a problem

with the request.');
}
 } }
//console.log('Caught Exception: ' + error);
date from the server");
}
} }
} }
catch( error ) {
        self.refreshOnLoadOnceHandler = function(event) {
                // get the last modified date
                if (self.refreshRequest.response) {
                        self.lastModifiedDate =
self.getLastModified(self.refreshRequest);
                        if (self.lastModifiedDate!=null) {
                                if (self.refreshInterval==null) {
                                        self.refreshInterval =
setInterval(self.requestRefreshUpdate, self.refreshDuration);
} }
                        else {
                                self.log("Could not get last modified
        self.refreshUpdatedPage = function() {
                if (self.showRefreshNotifications) {
                        var date = new Date().setTime((new
Date().getTime()+10000));
                        document.cookie =
encodeURIComponent(self.pageRefreshedName) + "=true" + "; max-
age=6000;" + " path=/";
                }
}
document.location.reload(true);
        self.showNotification = function(duration) {
                var notificationID = self.pageRefreshedName+"ID";
                var notification =
document.getElementById(notificationID);
                if (duration==null) duration = 4000;
                if (notification!=null) {return;}
                notification = document.createElement("div");
                notification.id = notificationID;
                notification.textContent = "PAGE UPDATED";
                var styleRule = ""
                styleRule = "position: fixed; padding: 7px 16px 6px
16px; font-family: Arial, sans-serif; font-size: 10px; font-weight:

bold; left: 50%;";
                styleRule += "top: 20px; background-color:
rgba(0,0,0,.5); border-radius: 12px; color:rgb(235, 235, 235);
transition: all 2s linear;";
                styleRule += "transform: translateX(-50%); letter-
spacing: .5px; filter: drop-shadow(2px 2px 6px rgba(0, 0, 0, .1))";
                notification.setAttribute("style", styleRule);
                notification.className= "PageRefreshedClass";
                document.body.appendChild(notification);
                setTimeout(function() {
                        notification.style.opacity = "0";
                        notification.style.filter = "drop-shadow( 0px
0px 0px rgba(0,0,0, .5))";
                        setTimeout(function() {
notification.parentNode.removeChild(notification);
                        }, duration)
                }, duration);
                document.cookie =
encodeURIComponent(self.pageRefreshedName) + "=; max-age=1; path=/";
}
        /**
         * Get the last modified date from the header
         * or file object after request has been received
         **/
        self.getLastModified = function(request) {
                var date;
 property {
// file protocol - FILE object with last modified
if (request.response && request.response.lastModified)
Modified");
                }
date = request.getResponseHeader("Last-
}
return date;
}
date = request.response.lastModified;
// http protocol - check headers
if (date==null) {
        self.updateLastModifiedLabel = function() {
                var labelValue = "";
                if (self.lastModifiedLabel==null) {
                        self.lastModifiedLabel =
document.getElementById("LastModifiedLabel");
                }

                if (self.lastModifiedLabel) {
                        var seconds = parseInt(((new Date().getTime()
- Date.parse(document.lastModified)) / 1000 / 60) * 100 + "");
                        var minutes = 0;
var hours = 0;
                        if (seconds < 60) {
                                seconds = Math.floor(seconds/10)*10;
                                labelValue = seconds + " seconds";
}
else {
parseInt((seconds/60/60) +"");
hour" : " hours";
 minute" : " minutes";
                        }
labelValue = minutes+"";
labelValue += minutes==1 ? "
" ago";
labelValue = "Updated " + labelValue +
minutes = parseInt((seconds/60) + "");
if (minutes>60) {
        hours =
        labelValue += hours==1 ? "
}
else {
        }
if (seconds<10) {
labelValue = "Updated now";
}
else {
}
if (self.lastModifiedLabel.firstElementChild)
{
self.lastModifiedLabel.firstElementChild.textContent = labelValue;
                        }
                        else if ("textContent" in
self.lastModifiedLabel) {
self.lastModifiedLabel.textContent =
labelValue;
}
} }
        self.getShortString = function(string, length) {
                if (length==null) length = 30;
                string = string!=null ? string.substr(0,
length).replace(/\n/g, "") : "[String is null]";
}
return string;
self.getShortNumber = function(value, places) {
        if (places==null || places<1) places = 4;

                value = Math.round(value * Math.pow(10,places)) /
Math.pow(10, places);
 viewName;
if (self.showViewName) {
        viewNavigationLabel.textContent =
}
return value;
        ///////////////////////////////////////
        // NAVIGATION CONTROLS
        ///////////////////////////////////////
        self.updateViewLabel = function() {
                var viewNavigationLabel =
document.getElementById("ViewNavigationLabel");
                var view = self.getVisibleView();
                var viewIndex = view ? self.getViewIndex(view) : -1;
                var viewName = view ?
self.getViewPreferenceValue(view, self.prefix + "view-name") : null;
var viewId = view ? view.id : null;
if (viewNavigationLabel && view) {
        if (viewName && viewName.indexOf('"')!=-1) {
}
viewName = viewName.replace(/"/g, "");
                                self.setTooltip(viewNavigationLabel,
viewIndex + 1 + " of " + self.numberOfViews);
}
else {
                                viewNavigationLabel.textContent =
viewIndex + 1 + " of " + self.numberOfViews;
viewName);
} }
self.setTooltip(viewNavigationLabel,
}
        self.updateURL = function(view) {
                view = view == null ? self.getVisibleView() : view;
                var viewId = view ? view.id : null
                var viewFragment = view ? "#"+ viewId : null;
                if (viewId && self.viewIds.length>1 &&
self.enableDeepLinking) {
                        if (self.supportsPopState==false) {
                                self.setFragment(viewId);
}
else {
                                if
(viewFragment!=window.location.hash) {
(window.location.hash==null) {
if

window.history.replaceState({name:viewId}, null, viewFragment);
                                        }
else {
window.history.pushState({name:viewId}, null, viewFragment);
 hover
self.setTooltip = function(element, value) {
        // setting the tooltip in edge causes a page crash on
}
}
window.location.hash = "#" + value;
} }
element.title = value;
} }
} }
        self.updateURLState = function(view, stateName) {
                stateName = view && (stateName=="" || stateName==null)
? self.getStateNameByViewId(view.id) : stateName;
                if (self.supportsPopState==false) {
                        self.setFragment(stateName);
}
else {
                        if (stateName!=window.location.hash) {
                                if (window.location.hash==null) {
window.history.replaceState({name:view.viewId}, null, stateName);
}
else {
window.history.pushState({name:view.viewId}, null, stateName);
} }
} }
self.setFragment = function(value) {
if (/Edge/.test(navigator.userAgent)) { return; }
if ("title" in element) {
self.getStylesheetRules = function(styleSheet) {
try {
styleSheet.rules;
if (styleSheet) return styleSheet.cssRules ||
                        return document.styleSheets[0]["cssRules"] ||
document.styleSheets[0]["rules"];
                }
                catch (error) {
// ERRORS:

                        // SecurityError: The operation is insecure.
                        // Errors happen when script loads before
stylesheet or loading an external css locally
                        // InvalidAccessError: A parameter or an
operation is not supported by the underlying object
                        // Place script after stylesheet
                        console.log(error);
                        if (error.toString().indexOf("The operation is
 insecure")!=-1) {
before the script or load the stylesheet inline until it can be loaded
on a server")
} }
        console.log("Load the stylesheet
return [];
}
        /**
         * If single page application hide all of the views.
         * @param {Number} selectedIndex if provided shows the view at
index provided
         **/
        self.hideViews = function(selectedIndex, animation) {
                var rules = self.getStylesheetRules();
                var queryIndex = 0;
                var numberOfRules = rules!=null ? rules.length : 0;
selected
// loop through rules and hide media queries except
for (var i=0;i<numberOfRules;i++) {
        var rule = rules[i];
        if (rule.media!=null) {
                if (queryIndex==selectedIndex) {
                        self.currentQuery.mediaText =
                        self.currentQuery.index =
                        self.currentQuery.rule = rule;
                        self.enableMediaQuery(rule);
}
else {
}
rule.conditionText;
selectedIndex;
self.disableMediaQuery(rule);
                                }
} }
        }
queryIndex++;
if (animation) {
        self.fadeOut(rule)
else {

 null;
/**
 * Hide view
 * @param {Object} view element to hide
 **/
self.hideView = function(view) {
        var rule = view ? self.mediaQueryDictionary[view.id] :
}
self.numberOfViews = queryIndex;
self.updateViewLabel();
self.updateURL();
self.dispatchViewChange();
var view = self.getVisibleView();
var viewIndex = view ? self.getViewIndex(view) : -1;
return viewIndex==selectedIndex ? view : null;
} }
self.disableMediaQuery(rule);
if (rule) {
/**
 * Hide overlay
 * @param {Object} overlay element to hide
 **/
self.hideOverlay = function(overlay) {
        var rule = overlay ?
self.mediaQueryDictionary[overlay.id] : null;
}
if (rule) {
        self.disableMediaQuery(rule);
        //if (self.showByMediaQuery) {
//} }
overlay.style.display = "none";
        /**
         * Show the view by media query. Does not hide current views
         * Sets view options by default
         * @param {Object} view element to show
         * @param {Boolean} setViewOptions sets view options if null
or true
*/
        self.showViewByMediaQuery = function(view, setViewOptions) {
                var id = view ? view.id : null;
setViewOptions;
var query = id ? self.mediaQueryDictionary[id] : null;
var isOverlay = view ? self.isOverlay(view) : false;
setViewOptions = setViewOptions==null ? true :

                if (query) {
                        self.enableMediaQuery(query);
                        if (isOverlay && view && setViewOptions) {
                                self.setViewVariables(null, view);
}
else {
self.setViewOptions(view);
self.setViewVariables(view);
 setViewOptions;
var query = id ? self.mediaQueryDictionary[id] : null;
var display = null;
setViewOptions = setViewOptions==null ? true :
if (query) {
        self.enableMediaQuery(query);
        if (view==null) view =self.getVisibleView();
}
} }
                        if (view && setViewOptions)
self.setViewOptions(view);
                }
                else if (id) {
                        display =
window.getComputedStyle(view).getPropertyValue("display");
                        if (display=="" || display=="none") {
} }
} }
view.style.display = "block";
if (view && setViewOptions)
if (view && setViewOptions)
/**
 * Show the view. Does not hide current views
 */
self.showView = function(view, setViewOptions) {
        var id = view ? view.id : null;
if (view) {
        if (self.currentView!=null) {
        self.lastView = self.currentView;
self.currentView = view;
}
self.showViewById = function(id, setViewOptions) {
        var view = id ? self.getViewById(id) : null;
        if (view) {
                self.showView(view);
return; }
        self.log("View not found '" + id + "'");

}
self.getElementView = function(element) {
        var view = element;
        var viewFound = false;
        while (viewFound==false || view==null) {
                if (view && self.viewsDictionary[view.id]) {
 } }
        return view;
view = view.parentNode;
}
        /**
         * Show overlay over view
         * @param {Event | HTMLElement} event event or html element
with styles applied
         * @param {String} id id of view or view reference
         * @param {Number} x x location
         * @param {Number} y y location
         */
        self.showOverlay = function(event, id, x, y) {
                var overlay = id && typeof id === 'string' ?
self.getViewById(id) : id ? id : null;
                var query = overlay ?
self.mediaQueryDictionary[overlay.id] : null;
                var centerHorizontally = false;
                var centerVertically = false;
                var anchorLeft = false;
                var anchorTop = false;
                var anchorRight = false;
                var anchorBottom = false;
                var display = null;
                var reparent = true;
                var view = null;
                if (overlay==null || overlay==false) {
                        self.log("Overlay not found, '"+ id + "'");
return; }
                // get enter animation - event target must have css
variables declared
                if (event) {
                        var button = event.currentTarget || event; //
can be event or htmlelement
                        var buttonComputedStyles =
getComputedStyle(button);
                        var actionTargetValue =
buttonComputedStyles.getPropertyValue(self.prefix+"action-
target").trim();
                        var animation =
buttonComputedStyles.getPropertyValue(self.prefix+"animation").trim();
                        var isAnimated = animation!="";
                        var targetType =
buttonComputedStyles.getPropertyValue(self.prefix+"action-

type").trim();
                        var actionTarget = self.application ? null :
self.getElement(actionTargetValue);
                        var actionTargetStyles = actionTarget ?
actionTarget.style : null;
                        if (actionTargetStyles) {
actionTargetStyles.setProperty("animation", animation);
                        }
                        if ("stopImmediatePropagation" in event) {
 actionTargetValue;
                }
document.location.href = "./" +
return;
self.currentOverlay==null) {
self.removeOverlay(isAnimated);
}
else {
} }
if (self.lastTrigger==button) {
return; }
overlay.style.display;
{
var display = overlay &&
if (overlay && display=="" || display=="none")
        overlay.style.display = "block";
                event.stopImmediatePropagation();
if (self.application==false || targetType=="page") {
} }
// remove any current overlays
if (self.currentOverlay) {
        // act as switch if same button
        if (self.currentOverlay==actionTarget ||
} }
view.appendChild(overlay);
self.removeOverlay(isAnimated);
if (reparent) {
        view = self.getElementView(button);
        if (view) {
if (query) {
        //self.setElementAnimation(overlay, null);
        //overlay.style.animation = animation;
        self.enableMediaQuery(query);

declaration
animation);
}
        // add animation defined in event target style
        if (animation && self.supportAnimations) {
                self.fadeIn(overlay, false,
} }
else if (id) {
                        display =
window.getComputedStyle(overlay).getPropertyValue("display");
declaration
animation);
                }
// add animation defined in event target style
if (animation && self.supportAnimations) {
        self.fadeIn(overlay, false,
}
//self.setViewOptions(overlay);
 if (display=="" || display=="none") {
}
overlay.style.display = "block";
                // do not set x or y position if centering
                var horizontal = self.prefix + "center-horizontally";
                var vertical = self.prefix + "center-vertically";
                var style = overlay.style;
                var transform = [];
                centerHorizontally = self.getIsStyleDefined(id,
horizontal) ? self.getViewPreferenceBoolean(overlay, horizontal) :
false;
                centerVertically = self.getIsStyleDefined(id,
vertical) ? self.getViewPreferenceBoolean(overlay, vertical) : false;
                anchorLeft = self.getIsStyleDefined(id, "left");
                anchorRight = self.getIsStyleDefined(id, "right");
                anchorTop = self.getIsStyleDefined(id, "top");
                anchorBottom = self.getIsStyleDefined(id, "bottom");
                if (self.viewsDictionary[overlay.id] &&
self.viewsDictionary[overlay.id].styleDeclaration) {
                        style =
self.viewsDictionary[overlay.id].styleDeclaration.style;
}
                if (centerHorizontally) {
                        style.left = "50%";
                        style.transformOrigin = "0 0";
                        transform.push("translateX(-50%)");
                }
                else if (anchorRight && anchorLeft) {
style.left = x + "px";

&& animate) {
if (overlay) {
        var style = overlay.style;
        if (style.animation && self.supportAnimations
                self.reverseAnimation(overlay, true);
                var duration =
}
self.currentOverlay = overlay;
self.lastTrigger = button;
}
else if (anchorRight) {
        //style.right = x + "px";
}
else {
}
 style.left = x + "px";
if (centerVertically) {
        style.top = "50%";
        transform.push("translateY(-50%)");
        style.transformOrigin = "0 0";
}
else if (anchorTop && anchorBottom) {
        style.top = y + "px";
else if (anchorBottom) {
        //style.bottom = y + "px";
}
else {
        style.top = y + "px";
if (transform.length) {
}
}
}
style.transform = transform.join(" ");
self.goBack = function() {
        if (self.currentOverlay) {
                self.removeOverlay();
        else if (self.lastView) {
}
} }
self.goToView(self.lastView.id);
self.removeOverlay = function(animate) {
        var overlay = self.currentOverlay;
        animate = animate===false ? false : true;
self.getAnimationDuration(style.animation, true);
                                setTimeout(function() {
self.setElementAnimation(overlay, null);

null);
}
self.setElementAnimation(overlay,
self.hideOverlay(overlay);
self.currentOverlay = null;
null);
var isOverlay = self.isOverlay(target);
setTimeout(function() {
        self.setElementAnimation(target,
        if (isOverlay) {
                self.hideOverlay(target);
}
else {
        }
}, duration);
                        self.hideOverlay(overlay);
                        self.currentOverlay = null;
                }, duration);
}
else {
} }
         /**
         * Reverse the animation and hide after
         * @param {Object} target element with animation
         * @param {Boolean} hide hide after animation ends
         */
        self.reverseAnimation = function(target, hide) {
                var lastAnimation = null;
                var style = target.style;
                style.animationPlayState = "paused";
                lastAnimation = style.animation;
                style.animation = null;
                style.animationPlayState = "paused";
                if (hide) {
                        //target.addEventListener("animationend",
self.animationEndHideHandler);
                        var duration =
self.getAnimationDuration(lastAnimation, true);
}
        setTimeout(function() {
                style.animation = lastAnimation;
                style.animationPlayState = "paused";
                style.animationDirection = "reverse";
                style.animationPlayState = "running";
}, 30); }
self.animationEndHandler = function(event) {
self.hideView(target);

 }
var target = event.currentTarget;
self.dispatchEvent(new Event(event.type));
        self.isOverlay = function(view) {
                var result = view ?
self.getViewPreferenceBoolean(view, self.prefix + "is-overlay") :
false;
}
return result;
        self.animationEndHideHandler = function(event) {
                var target = event.currentTarget;
                self.setViewVariables(null, target);
                self.hideView(target);
                target.removeEventListener("animationend",
self.animationEndHideHandler);
        }
        self.animationEndShowHandler = function(event) {
                var target = event.currentTarget;
                target.removeEventListener("animationend",
self.animationEndShowHandler);
        }
        self.setViewOptions = function(view) {
                if (view) {
                        self.minimumScale =
self.getViewPreferenceValue(view, self.prefix + "minimum-scale");
                        self.maximumScale =
self.getViewPreferenceValue(view, self.prefix + "maximum-scale");
                        self.scaleViewsToFit =
self.getViewPreferenceBoolean(view, self.prefix + "scale-to-fit");
                        self.scaleToFitType =
self.getViewPreferenceValue(view, self.prefix + "scale-to-fit-type");
                        self.scaleToFitOnDoubleClick =
self.getViewPreferenceBoolean(view, self.prefix + "scale-on-double-
click");
self.getViewPreferenceBoolean(view, self.prefix + "actual-size-on-
double-click");
                        self.scaleViewsOnResize =
self.getViewPreferenceBoolean(view, self.prefix + "scale-on-resize");
                        self.enableScaleUp =
self.getViewPreferenceBoolean(view, self.prefix + "enable-scale-up");
                        self.centerHorizontally =
self.getViewPreferenceBoolean(view, self.prefix + "center-
self.actualSizeOnDoubleClick =
horizontally");
self.getViewPreferenceBoolean(view, self.prefix + "center-
vertically");
                        self.navigationOnKeypress =
self.getViewPreferenceBoolean(view, self.prefix + "navigate-on-
keypress");
self.centerVertically =
self.showViewName =

self.getViewPreferenceBoolean(view, self.prefix + "show-view-name");
                        self.refreshPageForChanges =
self.getViewPreferenceBoolean(view, self.prefix + "refresh-for-
changes");
                        self.refreshPageForChangesInterval =
self.getViewPreferenceValue(view, self.prefix + "refresh-interval");
                        self.showNavigationControls =
self.getViewPreferenceBoolean(view, self.prefix + "show-navigation-
 controls");
self.getViewPreferenceBoolean(view, self.prefix + "show-scale-
query");
self.showUpdateNotification =
self.scaleViewSlider =
controls");
self.getViewPreferenceBoolean(view, self.prefix + "enable-deep-
linking");
                        self.singlePageApplication =
self.getViewPreferenceBoolean(view, self.prefix + "application");
                        self.showByMediaQuery =
self.getViewPreferenceBoolean(view, self.prefix + "show-by-media-
self.enableDeepLinking =
document.cookie!="" ?
document.cookie.indexOf(self.pageRefreshedName)!=-1 : false;
                        self.imageComparisonDuration =
self.getViewPreferenceValue(view, self.prefix + "image-comparison-
duration");
                        self.supportAnimations =
self.getViewPreferenceBoolean(view, self.prefix + "enable-animations",
true);
self.scaleViewToFit(view);
setTimeout(self.scaleViewToFit, 500, view);
} }
else {
self.getViewScaleValue(view);
if (self.scaleViewsToFit) {
        var newScaleValue =
                                self.viewToFitWidthScale =
self.getViewFitToViewportWidthScale(view, self.enableScaleUp)
                                self.viewToFitHeightScale =
self.getViewFitToViewportScale(view, self.enableScaleUp);
self.updateSliderValue(self.viewScale);
                        }
{
if (self.imageComparisonDuration!=null) {
// todo }
if (self.refreshPageForChangesInterval!=null)
        self.refreshDuration =
if (newScaleValue<0) {
self.viewScale =

Number(self.refreshPageForChangesInterval);
 selected
if (prevQueryIndex<0) {
return; }
// loop through rules and hide media queries except
for (var i=0;i<numberOfRules;i++) {
        var rule = rules[i];
        if (rule.media!=null) {
                if (queryIndex==prevQueryIndex) {
                        self.currentQuery.mediaText =
                        self.currentQuery.index =
                        self.currentQuery.rule = rule;
                        self.enableMediaQuery(rule);
                        self.updateViewLabel();
                        self.updateURL();
                        self.dispatchViewChange();
}
else {
                        self.disableMediaQuery(rule);
                queryIndex++;
}
} }
        self.previousView = function(event) {
                var rules = self.getStylesheetRules();
                var view = self.getVisibleView()
                var index = view ? self.getViewIndex(view) : -1;
                var prevQueryIndex = index!=-1 ? index-1 :
self.currentQuery.index-1;
                var queryIndex = 0;
rule.conditionText;
prevQueryIndex;
}
} }
var numberOfRules = rules!=null ? rules.length : 0;
if (event) {
}
event.stopImmediatePropagation();
}
        self.nextView = function(event) {
                var rules = self.getStylesheetRules();
                var view = self.getVisibleView();
                var index = view ? self.getViewIndex(view) : -1;
                var nextQueryIndex = index!=-1 ? index+1 :
self.currentQuery.index+1;
                var queryIndex = 0;
var numberOfRules = rules!=null ? rules.length : 0;

                var numberOfMediaQueries =
self.getNumberOfMediaRules();
 selected
if (nextQueryIndex>=numberOfMediaQueries) {
return; }
// loop through rules and hide media queries except
for (var i=0;i<numberOfRules;i++) {
        var rule = rules[i];
        if (rule.media!=null) {
                if (queryIndex==nextQueryIndex) {
                        self.currentQuery.mediaText =
                        self.currentQuery.index =
                        self.currentQuery.rule = rule;
                        self.enableMediaQuery(rule);
                        self.updateViewLabel();
                        self.updateURL();
                        self.dispatchViewChange();
}
else {
                        self.disableMediaQuery(rule);
                queryIndex++;
rule.conditionText;
nextQueryIndex;
}
} }
if (event) {
}
event.stopImmediatePropagation();
/**
 * Enables a view via media query
 */
self.enableMediaQuery = function(rule) {
try {
        }
        catch(error) {
} }
//self.log(error);
rule.conditionText = self.inclusionQuery;
}
rule.media.mediaText = self.inclusionQuery;
self.disableMediaQuery = function(rule) {
try {
}
rule.media.mediaText = self.exclusionQuery;

action
}
}
for (var i=0;i<numberOfRules;i++) {
        if (rules[i].media!=null) { numberOfQueries++;
}
return numberOfQueries;
}
catch(error) {
 } }
rule.conditionText = self.exclusionQuery;
self.dispatchViewChange = function() {
        try {
                var event = new Event(self.NAVIGATION_CHANGE);
                window.dispatchEvent(event);
        }
        catch (error) {
                // In IE 11: Object doesn't support this
}
self.getNumberOfMediaRules = function() {
        var rules = self.getStylesheetRules();
        var numberOfRules = rules ? rules.length : 0;
        var numberOfQueries = 0;
/////////////////////////////////////////
// VIEW SCALE
/////////////////////////////////////////
self.sliderChangeHandler = function(event) {
        var value =
self.getShortNumber(event.currentTarget.value/100);
                var view = self.getVisibleView();
}
self.setViewScaleValue(view, false, value, true);
        self.updateSliderValue = function(scale) {
                var slider =
document.getElementById(self.viewScaleSliderId);
                var tooltip = parseInt(scale * 100 + "") + "%";
"type");
var inputType;
var inputValue;
if (slider) {
        inputValue = self.getShortNumber(scale * 100);
        if (inputValue!=slider["value"]) {
                slider["value"] = inputValue;
        inputType = slider.getAttributeNS(null,
        if (inputType!="range") {
                // input range is not supported
}

null;
self.viewChangeHandler = function(event) {
        var view = self.getVisibleView();
        var matrix = view ? getComputedStyle(view).transform :
        if (matrix) {
                self.viewScale = self.getViewScaleValue(view);
} }
                        var scaleNeededToFit =
self.getViewFitToViewportScale(view);
scaleNeededToFit<1;
enabled
}
}
} }
        slider.style.display = "none";
self.setTooltip(slider, tooltip);
 }
                        var isViewLargerThanViewport =
                        // scale large view to fit if scale to fit is
                        if (self.scaleViewsToFit) {
                                self.scaleViewToFit(view);
                        else {
self.updateSliderValue(self.viewScale);
self.getViewScaleValue = function(view) {
        var matrix = getComputedStyle(view).transform;
        if (matrix) {
                var matrixArray = matrix.replace("matrix(",
"").split(",");
                }
var scaleX = parseFloat(matrixArray[0]);
var scaleY = parseFloat(matrixArray[3]);
var scale = Math.min(scaleX, scaleY);
}
return scale;
        /**
         * Scales view to scale.
         * @param {Object} view view to scale. views are in views
array
         * @param {Boolean} scaleToFit set to true to scale to fit.
set false to use desired scale value
         * @param {Number} desiredScale scale to define. not used if
scale to fit is false
callee
* @param {Boolean} isSliderChange indicates if slider is
*/

        self.setViewScaleValue = function(view, scaleToFit,
desiredScale, isSliderChange) {
                var enableScaleUp = self.enableScaleUp;
                var scaleToFitType = self.scaleToFitType;
                var minimumScale = self.minimumScale;
                var maximumScale = self.maximumScale;
                var hasMinimumScale = !isNaN(minimumScale) &&
minimumScale!="";
                var hasMaximumScale = !isNaN(maximumScale) &&
maximumScale!="";
                var scaleNeededToFit =
self.getViewFitToViewportScale(view, enableScaleUp);
                var scaleNeededToFitWidth =
self.getViewFitToViewportWidthScale(view, enableScaleUp);
                var scaleNeededToFitHeight =
self.getViewFitToViewportHeightScale(view, enableScaleUp);
                var scaleToFitFull =
self.getViewFitToViewportScale(view, true);
                var scaleToFitFullWidth =
self.getViewFitToViewportWidthScale(view, true);
                var scaleToFitFullHeight =
self.getViewFitToViewportHeightScale(view, true);
                var scaleToWidth = scaleToFitType=="width";
                var scaleToHeight = scaleToFitType=="height";
                var shrunkToFit = false;
                var topPosition = null;
                var leftPosition = null;
                var translateY = null;
                var translateX = null;
                var transformValue = "";
                var canCenterVertically = true;
                var canCenterHorizontally = true;
                var style = view.style;
                if (view && self.viewsDictionary[view.id] &&
self.viewsDictionary[view.id].styleDeclaration) {
                        style =
self.viewsDictionary[view.id].styleDeclaration.style;
                }
                if (scaleToFit && isSliderChange!=true) {
 scaleToFitType=="") {
}
}
} }
desiredScale = scaleNeededToFitHeight;
if (scaleToFitType=="fit" ||
        desiredScale = scaleNeededToFit;
else if (scaleToFitType=="width") {
        desiredScale = scaleNeededToFitWidth;
else if (scaleToFitType=="height") {
else {
        if (isNaN(desiredScale)) {
} }
desiredScale = 1;

                 self.updateSliderValue(desiredScale);
                // scale to fit width
                if (scaleToWidth && scaleToHeight==false) {
                        canCenterVertically =
scaleNeededToFitHeight>=scaleNeededToFitWidth;
                        canCenterHorizontally =
scaleNeededToFitWidth>=1 && enableScaleUp==false;
                        if (isSliderChange) {
                                canCenterHorizontally =
desiredScale<scaleToFitFullWidth;
                        }
                        else if (scaleToFit) {
desiredScale + ")";
                        }
}
desiredScale = scaleNeededToFitWidth;
                        if (hasMinimumScale) {
                                desiredScale = Math.max(desiredScale,
Number(minimumScale));
                        }
                        if (hasMaximumScale) {
                                desiredScale = Math.min(desiredScale,
Number(maximumScale));
                        }
                        desiredScale =
self.getShortNumber(desiredScale);
                        canCenterHorizontally =
self.canCenterHorizontally(view, "width", enableScaleUp, desiredScale,
minimumScale, maximumScale);
                        canCenterVertically =
self.canCenterVertically(view, "width", enableScaleUp, desiredScale,
minimumScale, maximumScale);
isSliderChange)) {
if (desiredScale>1 && (enableScaleUp ||
        transformValue = "scale(" +
                        else if (desiredScale>=1 &&
                                transformValue = "scale(" + 1 + ")";
}
else {
desiredScale + ")";
                        }
enableScaleUp==false) {
transformValue = "scale(" +
if (self.centerVertically) {
        if (canCenterVertically) {
}
translateY = "-50%";
topPosition = "50%";

translateY(" + translateY+ ")";
if (canCenterVertically) {
        transformValue += "
"";
if (style.left != leftPosition) {
        style.left = leftPosition +
}
if (canCenterHorizontally) {
        transformValue += "
translateX(" + translateX+ ")";
scaleNeededToFitWidth;
scaleNeededToFitHeight;
}
} }
style.transformOrigin = "0 0";
style.transform = transformValue;
self.viewScale = desiredScale;
self.viewToFitWidthScale =
self.viewToFitHeightScale =
self.viewLeft = leftPosition;
self.viewTop = topPosition;
return desiredScale;
else {
        translateY = "0";
        topPosition = "0";
if (style.top != topPosition) {
 }
}
style.top = topPosition + "";
} }
if (self.centerHorizontally) {
        if (canCenterHorizontally) {
                translateX = "-50%";
                leftPosition = "50%";
}
else {
}
                // scale to fit height
                if (scaleToHeight && scaleToWidth==false) {
                        //canCenterVertically =
scaleNeededToFitHeight>=scaleNeededToFitWidth;
                        //canCenterHorizontally =
scaleNeededToFitHeight<=scaleNeededToFitWidth && enableScaleUp==false;
canCenterVertically =
translateX = "0";
leftPosition = "0";

scaleNeededToFitHeight>=scaleNeededToFitWidth;
                        canCenterHorizontally =
scaleNeededToFitWidth>=1 && enableScaleUp==false;
                        if (isSliderChange) {
                                canCenterHorizontally =
desiredScale<scaleToFitFullHeight;
                        }
                        else if (scaleToFit) {
 isSliderChange)) {
if (desiredScale>1 && (enableScaleUp ||
        transformValue = "scale(" +
desiredScale + ")";
                        }
}
desiredScale = scaleNeededToFitHeight;
                        if (hasMinimumScale) {
                                desiredScale = Math.max(desiredScale,
Number(minimumScale));
                        }
Number(maximumScale));
if (hasMaximumScale) {
        desiredScale = Math.min(desiredScale,
                                //canCenterVertically =
desiredScale>=scaleNeededToFitHeight && enableScaleUp==false;
}
                        desiredScale =
self.getShortNumber(desiredScale);
                        canCenterHorizontally =
self.canCenterHorizontally(view, "height", enableScaleUp,
desiredScale, minimumScale, maximumScale);
                        canCenterVertically =
self.canCenterVertically(view, "height", enableScaleUp, desiredScale,
minimumScale, maximumScale);
                        else if (desiredScale>=1 &&
                                transformValue = "scale(" + 1 + ")";
}
else {
desiredScale + ")";
                        }
enableScaleUp==false) {
transformValue = "scale(" +
if (self.centerHorizontally) {
        if (canCenterHorizontally) {
                translateX = "-50%";
                leftPosition = "50%";
}
else {
}
translateX = "0";
leftPosition = "0";

 "";
if (style.left != leftPosition) {
        style.left = leftPosition +
}
if (canCenterHorizontally) {
        transformValue += "
translateX(" + translateX+ ")";
translateY(" + translateY+ ")";
if (canCenterVertically) {
        transformValue += "
scaleNeededToFitWidth;
scaleNeededToFitHeight;
}
} }
style.transformOrigin = "0 0";
style.transform = transformValue;
self.viewScale = desiredScale;
self.viewToFitWidthScale =
self.viewToFitHeightScale =
self.viewLeft = leftPosition;
self.viewTop = topPosition;
return scaleNeededToFitHeight;
} }
if (self.centerVertically) {
        if (canCenterVertically) {
                translateY = "-50%";
                topPosition = "50%";
}
else {
        }
        if (style.top != topPosition) {
                if (scaleToFitType=="fit") {
                        //canCenterVertically =
scaleNeededToFitHeight>=scaleNeededToFitWidth;
                        //canCenterHorizontally =
scaleNeededToFitWidth>=scaleNeededToFitHeight;
                        canCenterVertically =
scaleNeededToFitHeight>=scaleNeededToFit;
                        canCenterHorizontally =
scaleNeededToFitWidth>=scaleNeededToFit;
                        if (hasMinimumScale) {
}
style.top = topPosition + "";
translateY = "0";
topPosition = "0";

 Number(minimumScale));
                        }
desiredScale = Math.max(desiredScale,
                        desiredScale =
self.getShortNumber(desiredScale);
                        if (isSliderChange || scaleToFit==false) {
                                canCenterVertically =
scaleToFitFullHeight>=desiredScale;
                                canCenterHorizontally =
desiredScale<scaleToFitFullWidth;
                        }
")";
else if (scaleToFit) {
        desiredScale = scaleNeededToFit;
transformValue = "scale(" + desiredScale +
//canCenterHorizontally =
}
self.canCenterHorizontally(view, "fit", false, desiredScale);
                        //canCenterVertically =
self.canCenterVertically(view, "fit", false, desiredScale);
                        if (self.centerVertically) {
                                if (canCenterVertically) {
                                        translateY = "-50%";
                                        topPosition = "50%";
}
else {
                                }
                                if (style.top != topPosition) {
translateY(" + translateY+ ")";
if (canCenterVertically) {
        transformValue += "
}
style.top = topPosition + "";
translateY = "0";
topPosition = "0";
} }
if (self.centerHorizontally) {
        if (canCenterHorizontally) {
                translateX = "-50%";
                leftPosition = "50%";
}
else {
}
translateX = "0";
leftPosition = "0";
if (style.left != leftPosition) {
        style.left = leftPosition +

"";
}
if (canCenterHorizontally) {
        transformValue += "
 translateX(" + translateX+ ")";
scaleNeededToFitWidth;
scaleNeededToFitHeight;
}
} }
style.transformOrigin = "0 0";
style.transform = transformValue;
self.viewScale = desiredScale;
self.viewToFitWidthScale =
self.viewToFitHeightScale =
self.viewLeft = leftPosition;
self.viewTop = topPosition;
self.updateSliderValue(desiredScale);
return desiredScale;
                if (scaleToFitType=="default" || scaleToFitType=="") {
                        desiredScale = 1;
                        if (hasMinimumScale) {
                                desiredScale = Math.max(desiredScale,
Number(minimumScale));
                        }
                        if (hasMaximumScale) {
                                desiredScale = Math.min(desiredScale,
Number(maximumScale));
                        }
                        canCenterHorizontally =
self.canCenterHorizontally(view, "none", false, desiredScale,
minimumScale, maximumScale);
                        canCenterVertically =
self.canCenterVertically(view, "none", false, desiredScale,
minimumScale, maximumScale);
                        if (self.centerVertically) {
                                if (canCenterVertically) {
                                        translateY = "-50%";
                                        topPosition = "50%";
}
else {
}
translateY = "0";
topPosition = "0";
if (style.top != topPosition) {
}
style.top = topPosition + "";

 translateY(" + translateY+ ")";
if (canCenterVertically) {
        transformValue += "
"";
if (style.left != leftPosition) {
        style.left = leftPosition +
}
if (canCenterHorizontally) {
        transformValue += "
translateX(" + translateX+ ")";
                                }
translateX(" + 0 + ")";
                        }
else {
        transformValue += "
}
scaleNeededToFitWidth;
scaleNeededToFitHeight;
} }
style.transformOrigin = "0 0";
style.transform = transformValue;
self.viewScale = desiredScale;
self.viewToFitWidthScale =
self.viewToFitHeightScale =
self.viewLeft = leftPosition;
self.viewTop = topPosition;
self.updateSliderValue(desiredScale);
return desiredScale;
none
/**
 * Returns true if view can be centered horizontally
 * @param {HTMLElement} view view
 * @param {String} type type of scaling - width, height, all,
 * @param {Boolean} scaleUp if scale up enabled
 * @param {Number} scale target scale value
} }
if (self.centerHorizontally) {
        if (canCenterHorizontally) {
                translateX = "-50%";
                leftPosition = "50%";
}
else {
}
translateX = "0";
leftPosition = "0";

         */
        self.canCenterHorizontally = function(view, type, scaleUp,
scale, minimumScale, maximumScale) {
                var scaleNeededToFit =
self.getViewFitToViewportScale(view, scaleUp);
                var scaleNeededToFitHeight =
self.getViewFitToViewportHeightScale(view, scaleUp);
                var scaleNeededToFitWidth =
self.getViewFitToViewportWidthScale(view, scaleUp);
                var canCenter = false;
                var minScale;
                type = type==null ? "none" : type;
                scale = scale==null ? scale : scaleNeededToFitWidth;
                scaleUp = scaleUp == null ? false : scaleUp;
                if (type=="width") {
                        if (scaleUp && maximumScale==null) {
                                canCenter = false;
                        else if (scaleNeededToFitWidth>=1) {
 }
} }
canCenter = true;
                else if (type=="height") {
                        minScale = Math.min(1,
scaleNeededToFitHeight);
                        if (minimumScale!="" && maximumScale!="") {
                                minScale = Math.max(minimumScale,
Math.min(maximumScale, scaleNeededToFitHeight));
}
else {
Math.max(minimumScale, scaleNeededToFitHeight);
                                }
                                if (maximumScale!="") {
                                        minScale =
Math.max(minimumScale, Math.min(maximumScale,
scaleNeededToFitHeight));
                        }
                                canCenter = false;
                        else if (scaleNeededToFitWidth>=minScale) {
}
} }
canCenter = true;
                else if (type=="fit") {
                        canCenter =
scaleNeededToFitWidth>=scaleNeededToFit;
                }
                else {
                        if (scaleUp) {
if (minimumScale!="") {
        minScale =
        }
if (scaleUp && maximumScale=="") {

}
self.horizontalScrollbarsNeeded = canCenter;
return canCenter;
} }
canCenter = true;
        canCenter = false;
else if (scaleNeededToFitWidth>=1) {
 }
        /**
         * Returns true if view can be centered horizontally
         * @param {HTMLElement} view view to scale
         * @param {String} type type of scaling
         * @param {Boolean} scaleUp if scale up enabled
         * @param {Number} scale target scale value
         */
        self.canCenterVertically = function(view, type, scaleUp,
scale, minimumScale, maximumScale) {
                var scaleNeededToFit =
self.getViewFitToViewportScale(view, scaleUp);
                var scaleNeededToFitWidth =
self.getViewFitToViewportWidthScale(view, scaleUp);
                var scaleNeededToFitHeight =
self.getViewFitToViewportHeightScale(view, scaleUp);
                var canCenter = false;
                var minScale;
                type = type==null ? "none" : type;
                scale = scale==null ? 1 : scale;
                scaleUp = scaleUp == null ? false : scaleUp;
                if (type=="width") {
                        canCenter =
scaleNeededToFitHeight>=scaleNeededToFitWidth;
                }
                else if (type=="height") {
                        minScale = Math.max(minimumScale,
Math.min(maximumScale, scaleNeededToFit));
                        canCenter = scaleNeededToFitHeight>=minScale;
                }
                else if (type=="fit") {
                        canCenter =
scaleNeededToFitHeight>=scaleNeededToFit;
}
else {
}
if (scaleUp) {
        canCenter = false;
else if (scaleNeededToFitHeight>=1) {
                canCenter = true;
self.verticalScrollbarsNeeded = canCenter;
} }

 return canCenter;
}
        self.getViewFitToViewportScale = function(view, scaleUp) {
                var enableScaleUp = scaleUp;
                var availableWidth = window.innerWidth ||
document.documentElement.clientWidth || document.body.clientWidth;
                var availableHeight = window.innerHeight ||
document.documentElement.clientHeight || document.body.clientHeight;
                var elementWidth = parseFloat(getComputedStyle(view,
"style").width);
                var elementHeight = parseFloat(getComputedStyle(view,
"style").height);
                var newScale = 1;
values are NaN
}
return newScale;
// if element is not added to the document computed
if (isNaN(elementWidth) || isNaN(elementHeight)) {
                availableWidth -= self.horizontalPadding;
                availableHeight -= self.verticalPadding;
                if (enableScaleUp) {
                        newScale =
Math.min(availableHeight/elementHeight, availableWidth/elementWidth);
                }
                else if (elementWidth > availableWidth ||
elementHeight > availableHeight) {
                        newScale =
Math.min(availableHeight/elementHeight, availableWidth/elementWidth);
{
        }
        return newScale;
}
self.getViewFitToViewportWidthScale = function(view, scaleUp)
        // need to get browser viewport width when element
                var isParentWindow = view && view.parentNode &&
view.parentNode===document.body;
                var enableScaleUp = scaleUp;
                var availableWidth = window.innerWidth ||
document.documentElement.clientWidth || document.body.clientWidth;
                var elementWidth = parseFloat(getComputedStyle(view,
"style").width);
values are NaN
}
var newScale = 1;
// if element is not added to the document computed
if (isNaN(elementWidth)) {
        return newScale;
availableWidth -= self.horizontalPadding;

 {
        if (enableScaleUp) {
                newScale = availableWidth/elementWidth;
        else if (elementWidth > availableWidth) {
                newScale = availableWidth/elementWidth;
        return newScale;
}
self.getViewFitToViewportHeightScale = function(view, scaleUp)
        var enableScaleUp = scaleUp;
}
self.keypressHandler);
                }
self.keypressHandler);
                }
window.removeEventListener("keypress",
}
}
                var availableHeight = window.innerHeight ||
document.documentElement.clientHeight || document.body.clientHeight;
                var elementHeight = parseFloat(getComputedStyle(view,
"style").height);
values are NaN
}
return newScale;
var newScale = 1;
// if element is not added to the document computed
if (isNaN(elementHeight)) {
availableHeight -= self.verticalPadding;
if (enableScaleUp) {
        newScale = availableHeight/elementHeight;
else if (elementHeight > availableHeight) {
        newScale = availableHeight/elementHeight;
return newScale;
}
}
self.keypressHandler = function(event) {
        var rightKey = 39;
        var leftKey = 37;
        // listen for both events
        if (event.type=="keypress") {
        window.removeEventListener("keyup",
else {
if (self.showNavigationControls) {
        if (self.navigationOnKeypress) {
                if (event.keyCode==rightKey) {
}
self.nextView();

}
}
return view;
if (event.keyCode==leftKey) {
 } }
self.previousView();
}
else if (self.navigationOnKeypress) {
        if (event.keyCode==rightKey) {
                self.nextView();
        if (event.keyCode==leftKey) {
}
} }
self.previousView();
        ///////////////////////////////////
        // GENERAL FUNCTIONS
        ///////////////////////////////////
        self.getViewById = function(id) {
                id = id ? id.replace("#", "") : "";
                var view = self.viewIds.indexOf(id)!=-1 &&
self.getElement(id);
        self.getViewIds = function() {
                var viewIds =
self.getViewPreferenceValue(document.body, self.prefix + "view-ids");
                var viewId = null;
                viewIds = viewIds!=null && viewIds!="" ?
viewIds.split(",") : [];
                if (viewIds.length==0) {
                        viewId =
self.getViewPreferenceValue(document.body, self.prefix + "view-id");
                        viewIds = viewId ? [viewId] : [];
                return viewIds;
}
}
        self.getInitialViewId = function() {
                var viewId =
self.getViewPreferenceValue(document.body, self.prefix + "view-id");
}
return viewId;
        self.getApplicationStylesheet = function() {
                var stylesheetId =
self.getViewPreferenceValue(document.body, self.prefix + "stylesheet-
id");
                self.applicationStylesheet =
document.getElementById("applicationStylesheet");
}
return self.applicationStylesheet.sheet;

 self.getVisibleView = function() {
        var viewIds = self.getViewIds();
        for (var i=0;i<viewIds.length;i++) {
(.*)/, "$" + "1");
var viewId = viewIds[i].replace(/[\#?\.?]
var view = self.getElement(viewId);
var postName = "_Class";
                        if (view==null && viewId &&
viewId.lastIndexOf(postName)!=-1) {
                                view =
self.getElement(viewId.replace(postName, ""));
}
if (view) {
getComputedStyle(view).display;
display=="flex") {
var display =
if (display=="block" ||
}
} }
}
return null;
return view;
self.getVisibleViews = function() {
        var viewIds = self.getViewIds();
        var views = [];
        for (var i=0;i<viewIds.length;i++) {
(.*)/, "$" + "1");
var viewId = viewIds[i].replace(/[\#?\.?]
var view = self.getElement(viewId);
var postName = "_Class";
                        if (view==null && viewId &&
viewId.lastIndexOf(postName)!=-1) {
                                view =
self.getElement(viewId.replace(postName, ""));
}
if (view) {
getComputedStyle(view).display;
display=="flex") {
var display =
if (display=="none") {
continue;
}
if (display=="block" ||
views.push(view);

 }
} }
}
return views;
self.getStateNameByViewId = function(id) {
        var state = self.viewsDictionary[id];
}
return state && state.stateName;
self.getMatchingViews = function(ids) {
        var views = self.addedViews.slice(0);
        var matchingViews = [];
        if (self.showByMediaQuery) {
                for (let index = 0; index < views.length;
index++) {
self.viewsDictionary[viewId];
window.matchMedia(rule.conditionText);
matchingViews.push(viewId);
matchingViews.push(view);
var view = self.views[viewId];
if (matchResults.matches) {
        if (ids==true) {
}
else {
} }
index++) {
if (self.showByMediaQuery) {
        // find state name
        for (let index = 0; index < views.length;
}
return matchingViews;
} }
var viewId = views[index];
var state =
var rule = state && state.rule;
var matchResults =
self.ruleMatchesQuery = function(rule) {
        var result = window.matchMedia(rule.conditionText);
}
return result.matches;
self.getViewsByStateName = function(stateName, matchQuery) {
        var views = self.addedViews.slice(0);
        var matchingViews = [];

 self.viewsDictionary[viewId];
var viewId = views[index];
var state =
var rule = state.rule;
var mediaRule = state.mediaRule;
var view = self.views[viewId];
var viewStateName =
self.getStyleRuleValue(mediaRule, self.STATE_NAME, state);
                                var stateFoundAtt =
view.getAttribute(self.STATE_NAME)==state;
                                var matchesResults = false;
self.ruleMatchesQuery(rule);
matchingViews.push(view);
matchingViews.push(view);
if (viewStateName==stateName) {
        if (matchQuery) {
                matchesResults =
                if (matchesResults) {
                }
}
else {
} }
}
return matchingViews;
} }
        self.getInitialView = function() {
                var viewId = self.getInitialViewId();
                viewId = viewId.replace(/[\#?\.?](.*)/, "$" + "1");
                var view = self.getElement(viewId);
                var postName = "_Class";
                if (view==null && viewId &&
viewId.lastIndexOf(postName)!=-1) {
                        view =
self.getElement(viewId.replace(postName, ""));
}
}
return view;
self.getViewIndex = function(view) {
        var viewIds = self.getViewIds();
        var id = view ? view.id : null;
        var index = id && viewIds ? viewIds.indexOf(id) : -1;
        return index;
self.syncronizeViewToURL = function() {
}

self.getInitialView();
if (stateName==null || stateName=="") {
        var initialView =
currentView.id);
                }
}
}
self.setViewVariables(view);
return view;
var fragment = self.getHashFragment();
if (self.showByMediaQuery) {
        var stateName = fragment;
                                 stateName = initialView ?
self.getStateNameByViewId(initialView.id) : null;
}
                        self.showMediaQueryViewsByState(stateName);
return; }
                var view = self.getViewById(fragment);
                var index = view ? self.getViewIndex(view) : 0;
                if (index==-1) index = 0;
                var currentView = self.hideViews(index);
                if (self.supportsPopState && currentView) {
                        if (fragment==null) {
window.history.replaceState({name:currentView.id}, null, "#"+
currentView.id);
window.history.pushState({name:currentView.id}, null, "#"+
}
else {
        /**
         * Set the currentView or currentOverlay properties and set
the lastView or lastOverlay properties
         */
        self.setViewVariables = function(view, overlay, parentView) {
                if (view) {
                        if (self.currentView) {
                                self.lastView = self.currentView;
                        self.currentView = view;
                if (overlay) {
                        if (self.currentOverlay) {
                                self.lastOverlay =
                        self.currentOverlay = overlay;
self.currentOverlay;
                        }
} }

} }
self.getViewPreferenceBoolean = function(view, property,
 altValue) {
var computedStyle = window.getComputedStyle(view);
var value = computedStyle.getPropertyValue(property);
var type = typeof value;
                if (value=="true" || (type=="string" &&
value.indexOf("true")!=-1)) {
                        return true;
                else if (value=="" && arguments.length==3) {
                        return altValue;
                return false;
        }
        self.getViewPreferenceValue = function(view, property,
defaultValue) {
window.getComputedStyle(view).getPropertyValue(property);
(match, capture) {
                });
(match, capture) {
                });
}
}
var value =
if (value===undefined) {
}
return defaultValue;
                value = value.replace(/^[\s\"]*/, "");
                value = value.replace(/[\s\"]*$/, "");
                value = value.replace(/^[\s"]*(.*?)[\s"]*$/, function
}
        self.getStyleRuleValue = function(cssRule, property) {
                var value = cssRule ?
cssRule.style.getPropertyValue(property) : null;
                if (value===undefined) {
        return capture;
return value;
}
return null;
        value = value.replace(/^[\s\"]*/, "");
        value = value.replace(/[\s\"]*$/, "");
        value = value.replace(/^[\s"]*(.*?)[\s"]*$/, function
}
        return capture;
return value;

        /**
         * Get the first defined value of property. Returns empty
string if not defined
         * @param {String} id id of element
         * @param {String} property
         */
        self.getCSSPropertyValueForElement = function(id, property) {
                var styleSheets = document.styleSheets;
                var numOfStylesheets = styleSheets.length;
                var values = [];
                var selectorIDText = "#" + id;
                var selectorClassText = "." + id + "_Class";
                var value;
                for(var i=0;i<numOfStylesheets;i++) {
                        var styleSheet = styleSheets[i];
                        var cssRules =
self.getStylesheetRules(styleSheet);
                        var numOfCSSRules = cssRules.length;
var cssRule;
                        for (var j=0;j<numOfCSSRules;j++) {
                                cssRule = cssRules[j];
                                if (cssRule.media) {
                                        var mediaRules =
 cssRule.cssRules;
mediaRules ? mediaRules.length : 0;
k=0;k<numOfMediaRules;k++) {
mediaRules[k];
var numOfMediaRules =
for(var
        var mediaRule =
                                                if
mediaRule.selectorText==selectorClassText) {
(mediaRule.selectorText==selectorIDText ||
(mediaRule.style && mediaRule.style.getPropertyValue(property)!="") {
= mediaRule.style.getPropertyValue(property);
values.push(value);
} }
else {
                                        if
(cssRule.selectorText==selectorIDText ||
if
value
cssRule.selectorText==selectorClassText) {
cssRule.style.getPropertyValue(property)!="") {
} }
if (cssRule.style &&
        value =

cssRule.style.getPropertyValue(property);
values.push(value);
 property); }
var value = self.getCSSPropertyValueForElement(id,
return value!==undefined && value!="";
view
self.collectMediaQueries = function() {
        var viewIds = self.getViewIds();
        var styleSheet = self.getApplicationStylesheet();
        var cssRules = self.getStylesheetRules(styleSheet);
        var numOfCSSRules = cssRules ? cssRules.length : 0;
        var cssRule;
        var id = viewIds.length ? viewIds[0]: ""; // single
}
for (let index = 0; index < viewIds.length; index++) {
        const id = viewIds[index];
        const view = self.getElement(id);
        self.views[id] = view;
}
self.viewIds = viewIds;
} }
}
return values.pop();
} }
}
self.getIsStyleDefined = function(id, property) {
self.collectViews = function() {
        var viewIds = self.getViewIds();
self.collectOverlays = function() {
        var viewIds = self.getViewIds();
        var ids = [];
        for (let index = 0; index < viewIds.length; index++) {
                const id = viewIds[index];
self.isOverlay(view);
const view = self.getViewById(id);
const isOverlay = view &&
if (isOverlay) {
        ids.push(id);
}
self.overlayIds = ids;
} }
self.overlays[id] = view;

mediaRules.length : 0;
mediaRule.selectorText;
if (cssRule.media) {
        var mediaRules = cssRule.cssRules;
        var numOfMediaRules = mediaRules ?
        var mediaViewInfoFound = false;
        var mediaId = null;
        for(var k=0;k<numOfMediaRules;k++) {
                var mediaRule = mediaRules[k];
                selectorText =
var selectorIDText = "#" + id;
var selectorClassText = "." + id + "_Class";
var viewsNotFound = viewIds.slice();
var viewsFound = [];
var selectorText = null;
var property = self.prefix + "view-id";
var stateName = self.prefix + "state";
var stateValue;
for (var j=0;j<numOfCSSRules;j++) {
        cssRule = cssRules[j];
                                         if
(selectorText==".mediaViewInfo" && mediaViewInfoFound==false) {
self.getStyleRuleValue(mediaRule, property);
self.getStyleRuleValue(mediaRule, stateName);
mediaId;
"." + mediaId + "_Class";
from load and domcontentloaded events
(self.addedViews.indexOf(mediaId)==-1) {
self.addView(mediaId, cssRule, mediaRule, stateValue);
viewsFound.push(mediaId);
(viewsNotFound.indexOf(mediaId)!=-1) {
viewsNotFound.splice(viewsNotFound.indexOf(mediaId));
                                                }
true;
mediaViewInfoFound =
mediaId =
stateValue =
selectorIDText = "#" +
selectorClassText =
}
if
// prevent duplicates
if

}
                                        if
(selectorIDText==selectorText || selectorClassText==selectorText) {
 self.viewsDictionary[mediaId];
styleObject.styleDeclaration = mediaRule;
var styleObject =
if (styleObject) {
}
} }
break; }
                        else {
                                selectorText = cssRule.selectorText;
                                if (selectorText==null) continue;
                                selectorText =
selectorText.replace(/[#|\s|*]?/g, "");
{
cssRule, null, stateValue);
if (viewIds.indexOf(selectorText)!=-1)
        self.addView(selectorText,
                                        if
(viewsNotFound.indexOf(selectorText)!=-1) {
viewsNotFound.splice(viewsNotFound.indexOf(selectorText));
                                        }
{
self.addView = function(viewId, cssRule, mediaRule, stateName)
} }
break; }
                if (viewsNotFound.length) {
                        console.log("Could not find the following
views:" + viewsNotFound.join(",") + "");
                        console.log("Views found:" +
viewsFound.join(",") + "");
} }
        /**
         * Adds a view. A view object contains the id of the view and
the style rule
         * Use enableMediaQuery(rule) to enable
         * An array of view names are in self.addedViews array
         */
                var state = {name:viewId, rule:cssRule, id:viewId,
mediaRule:mediaRule, stateName:stateName};
self.addedViews.push(viewId);

        self.viewsDictionary[viewId] = state;
        self.mediaQueryDictionary[viewId] = cssRule;
}
self.hasView = function(name) {
        if (self.addedViews.indexOf(name)!=-1) {
 } }
maintainPreviousState==null) {
self.hideViews();
        return true;
return false;
        /**
         * Go to view by id. Views are added in addView()
         * @param {String} id id of view in current
         * @param {Boolean} maintainPreviousState if true then do not
hide other views
         * @param {String} parent id of parent view
         */
        self.goToView = function(id, maintainPreviousState, parent) {
                var state = self.viewsDictionary[id];
                if (state) {
                        if (maintainPreviousState==false ||
                }
                self.enableMediaQuery(state.rule);
                self.updateViewLabel();
                self.updateURL();
}
else {
} }
var event = new Event(self.STATE_NOT_FOUND);
self.stateName = id;
window.dispatchEvent(event);
        /**
         * Go to the view in the event targets CSS variable
         */
        self.goToTargetView = function(event) {
                var button = event.currentTarget;
                var buttonComputedStyles = getComputedStyle(button);
                var actionTargetValue =
buttonComputedStyles.getPropertyValue(self.prefix+"action-
target").trim();
                var animation =
buttonComputedStyles.getPropertyValue(self.prefix+"animation").trim();
                var targetType =
buttonComputedStyles.getPropertyValue(self.prefix+"action-
type").trim();
                var targetView = self.application ? null :
self.getElement(actionTargetValue);
                var targetState = targetView ?
self.getStateNameByViewId(targetView.id) : null;
var actionTargetStyles = targetView ? targetView.style

: null;
var state = self.viewsDictionary[actionTargetValue];
// navigate to page
if (self.application==false || targetType=="page") {
 actionTargetValue;
                }
document.location.href = "./" +
return;
declaration
return; }
// add animation set in event target style
if (animation && self.supportAnimations) {
// if view is found
if (targetView) {
        if (self.currentOverlay) {
}
self.removeOverlay(false);
                        if (self.showByMediaQuery) {
                                var stateName = targetState;
}
self.showMediaQueryViewsByState(stateName, event);
{
self.getInitialView();
self.getStateNameByViewId(initialView.id) : null;
if (stateName==null || stateName=="")
        var initialView =
                                self.crossFade(self.currentView,
else {
self.setViewVariables(self.currentView);
                                self.hideViews();
targetView, false, animation);
                        }
} }
self.enableMediaQuery(state.rule);
self.scaleViewIfNeeded(targetView);
self.centerView(targetView);
self.updateViewLabel();
self.updateURL();
                else {
                        var stateEvent = new
Event(self.STATE_NOT_FOUND);
                        self.stateName = name;
        window.dispatchEvent(stateEvent);
event.stopImmediatePropagation();
}
stateName = initialView ?

}
        /**
         * Cross fade between views
         **/
        self.crossFade = function(from, to, update, animation) {
                var targetIndex = to.parentNode
                var fromIndex =
Array.prototype.slice.call(from.parentElement.children).indexOf(from);
                var toIndex =
Array.prototype.slice.call(to.parentElement.children).indexOf(to);
                if (from.parentNode==to.parentNode) {
                        var reverse =
self.getReverseAnimation(animation);
                        var duration =
self.getAnimationDuration(animation, true);
 instantly
null);
null);
// if target view is above (higher index)
// then fade in target view
// and after fade in then hide previous view
if (fromIndex<toIndex) {
        self.setElementAnimation(from, null);
        self.setElementAnimation(to, null);
        self.showViewByMediaQuery(to);
        self.fadeIn(to, update, animation);
        setTimeout(function() {
                self.setElementAnimation(to,
                self.setElementAnimation(from,
                self.hideView(from);
                self.updateURL();
                self.setViewVariables(to);
                self.updateViewLabel();
}, duration)
}
// if target view is on bottom
// then show target view instantly
// and fade out current view
else if (fromIndex>toIndex) {
        self.setElementAnimation(to, null);
        self.setElementAnimation(from, null);
        self.showViewByMediaQuery(to);
        self.fadeOut(from, update, reverse);
        setTimeout(function() {
                self.setElementAnimation(to,
                self.setElementAnimation(from,
                self.hideView(from);
                self.updateURL();
                self.setViewVariables(to);
null);
null);
}, duration)

 }
} }
self.fadeIn = function(element, update, animation) {
        self.showViewByMediaQuery(element);
        if (update) {
                self.updateURL(element);
function(event) {
element.addEventListener("animationend",
        element.style.animation = null;
        self.setViewVariables(element);
        self.updateViewLabel();
element.removeEventListener("animationend", arguments.callee);
}
}); }
self.setElementAnimation(element, null);
element.style.animation = animation;
self.fadeOutCurrentView = function(animation, update) {
        if (self.currentView) {
animation);
                }
self.fadeOut(self.currentView, update,
animation);
if (self.currentOverlay) {
        self.fadeOut(self.currentOverlay, update,
} }
self.fadeOut = function(element, update, animation) {
        if (update) {
function(event) {
element.addEventListener("animationend",
        element.style.animation = null;
        self.hideView(element);
element.removeEventListener("animationend", arguments.callee);
}
}); }
element.style.animationPlayState = "paused";
element.style.animation = animation;
element.style.animationPlayState = "running";
self.getReverseAnimation = function(animation) {
        if (animation && animation.indexOf("reverse")==-1) {
}
animation += " reverse";

}
priority) {
"important");
        }
element.style.setProperty("animation", animation,
return animation;
 }
        /**
         * Get duration in animation string
         * @param {String} animation animation value
         * @param {Boolean} inMilliseconds length in milliseconds if
true
*/
        self.getAnimationDuration = function(animation,
inMilliseconds) {
                var duration = 0;
                var expression = /.+(\d\.\d)s.+/;
                if (animation && animation.match(expression)) {
                        duration =
parseFloat(animation.replace(expression, "$" + "1"));
duration * 1000;
                }
if (duration && inMilliseconds) duration =
        return duration;
self.setElementAnimation = function(element, animation,
        self.getElement = function(id) {
                var elementId = id ? id.trim() : id;
                var element = elementId ?
document.getElementById(elementId) : null;
}
return element;
        self.getElementByClass = function(className) {
                className = className ? className.trim() : className;
                var elements =
document.getElementsByClassName(className);
                return elements.length ? elements[0] : null;
        }
        self.resizeHandler = function(event) {
                if (self.showByMediaQuery) {
                        if (self.enableDeepLinking) {
self.getHashFragment();
{
self.getInitialView();
var stateName =
if (stateName==null || stateName=="")
        var initialView =

                                        stateName = initialView ?
self.getStateNameByViewId(initialView.id) : null;
}
self.showMediaQueryViewsByState(stateName, event);
} }
                else {
                        var visibleViews = self.getVisibleViews();
                        for (let index = 0; index <
 visibleViews.length; index++) {
} }
var view = visibleViews[index];
self.scaleViewIfNeeded(view);
                window.dispatchEvent(new
Event(self.APPLICATION_RESIZE));
        }
        self.scaleViewIfNeeded = function(view) {
                if (self.scaleViewsOnResize) {
                        if (view==null) {
} }
self.centerView(view);
}
view = self.getVisibleView();
                        var isViewScaled = view.getAttributeNS(null,
self.SIZE_STATE_NAME)=="false" ? false : true;
                        if (isViewScaled) {
                                self.scaleViewToFit(view, true);
                        else {
}
                self.scaleViewToActualSize(view);
else if (view) {
} }
        self.centerView = function(view) {
                if (self.scaleViewsToFit) {
                        self.scaleViewToFit(view, true);
}
else {
                        self.scaleViewToActualSize(view);  // for
centering support for now
} }
        self.preventDoubleClick = function(event) {
}
event.stopImmediatePropagation();

         self.getHashFragment = function() {
                var value = window.location.hash ?
window.location.hash.replace("#", "") : "";
                return value;
        self.showBlockElement = function(view) {
                view.style.display = "block";
        self.hideElement = function(view) {
medium, large)
// browser will hide and show by media query (small,
}
}
}
view.style.display = "none";
self.showStateFunction = null;
self.showMediaQueryViewsByState = function(state, event) {
                // but if multiple views exists at same size user may
want specific view
                // if showStateFunction is defined that is called with
state fragment and user can show or hide each media matching view by
returning true or false
                // if showStateFunction is not defined and state is
defined and view has a defined state that matches then show that and
hide other matching views
                // if no state is defined show view
                // an viewChanging event is dispatched before views
are shown or hidden that can be prevented
                // get all matched queries
                // if state name is specified then show that view and
hide other views
                // if no state name is defined then show
                var matchedViews = self.getMatchingViews();
                var matchMediaQuery = true;
                var foundViews = self.getViewsByStateName(state,
matchMediaQuery);
                var showViews = [];
index++) {
state)) {
var hideViews = [];
// loop views that match media query
for (let index = 0; index < matchedViews.length;
        var view = matchedViews[index];
        // let user determine visible view
        if (self.showStateFunction!=null) {
                if (self.showStateFunction(view,
                        showViews.push(view);
                else {
                        hideViews.push(view);
} }

 state
}
// state was defined so check if view matches
else if (foundViews.length) {
        if (foundViews.indexOf(view)!=-1) {
                showViews.push(view);
        else {
{
hideViews.length; index++) {
self.removeOverlay(view);
self.hideElement(view);
showViews.length; index++) {
{
self.clearDisplay(view);
self.setViewOptions(view);
self.setViewVariables(view);
for (var index = 0; index <
        var view = hideViews[index];
        if (self.isOverlay(view)) {
}
else {
} }
for (var index = 0; index <
        var view = showViews[index];
        if (index==showViews.length-1)
                self.centerView(view);
} }
showViews.push(view);
}
} }
hideViews.push(view);
                        // if no state names are defined show view
(define unused state name to exclude)
                        else if (state==null || state=="") {
                if (showViews.length) {
                        var viewChangingEvent = new
Event(self.VIEW_CHANGING);
                        viewChangingEvent.showViews = showViews;
                        viewChangingEvent.hideViews = hideViews;
                        window.dispatchEvent(viewChangingEvent);
                        if (viewChangingEvent.defaultPrevented==false)
self.updateURLState(view, state);

 } }
viewChangeEvent.showViews = showViews;
viewChangeEvent.hideViews = hideViews;
window.dispatchEvent(viewChangeEvent);
self.getInitialView();
if (stateName==null || stateName=="") {
        var initialView =
}
} }
                        var viewChangeEvent = new
Event(self.VIEW_CHANGE);
self.clearDisplay = function(view) {
}
view.style.setProperty("display", null);
self.hashChangeHandler = function(event) {
        var fragment = self.getHashFragment();
        var view = self.getViewById(fragment);
        if (self.showByMediaQuery) {
                var stateName = fragment;
                                stateName = initialView ?
self.getStateNameByViewId(initialView.id) : null;
                        }
                        self.showMediaQueryViewsByState(stateName);
}
else {
Event(self.VIEW_CHANGE));
                        }
Event(self.VIEW_NOT_FOUND));
}
} }
if (view) {
        self.hideViews();
        self.showView(view);
        self.setViewVariables(view);
        self.updateViewLabel();
        window.dispatchEvent(new
else {
        self.popStateHandler = function(event) {
                var state = event.state;
                var fragment = state ? state.name :
window.location.hash;
                var view = self.getViewById(fragment);
                if (view) {
                        self.hideViews();
window.dispatchEvent(new

                        self.showView(view);
                        self.updateViewLabel();
}
else {
                        window.dispatchEvent(new
Event(self.VIEW_NOT_FOUND));
 1;
} }
self.doubleClickHandler = function(event) {
        var view = self.getVisibleView();
        var scaleValue = view ? self.getViewScaleValue(view) :
                var scaleNeededToFit = view ?
self.getViewFitToViewportScale(view) : 1;
                var scaleNeededToFitWidth = view ?
self.getViewFitToViewportWidthScale(view) : 1;
                var scaleNeededToFitHeight = view ?
self.getViewFitToViewportHeightScale(view) : 1;
                var scaleToFitType = self.scaleToFitType;
                // Three scenarios
                // - scale to fit on double click
                // - set scale to actual size on double click
                // - switch between scale to fit and actual page size
                if (scaleToFitType=="width") {
                        scaleNeededToFit = scaleNeededToFitWidth;
                else if (scaleToFitType=="height") {
                        scaleNeededToFit = scaleNeededToFitHeight;
                }
                // if scale and actual size enabled then switch
                if (self.scaleToFitOnDoubleClick &&
between
self.actualSizeOnDoubleClick) {
self.SIZE_STATE_NAME);
actual size
var isViewScaled = view.getAttributeNS(null,
var isScaled = false;
// if scale is not 1 then view needs scaling
if (scaleNeededToFit!=1) {
        // if current scale is at 1 it is at
        // scale it to fit
        if (scaleValue==1) {
                self.scaleViewToFit(view);
                isScaled = true;
}
else {
}
to actual size
self.scaleViewToActualSize(view);
// scale is not at 1 so switch
isScaled = false;

 size
same
centering
} }
else {
        // view is smaller than viewport
        // so scale to fit() is scale actual
}
// actual size and scaled size are the
// but call scale to fit to retain
self.scaleViewToFit(view);
isScaled = false;
                        view.setAttributeNS(null,
self.SIZE_STATE_NAME, isScaled+"");
self.SIZE_STATE_NAME);
                }
}
} }
self.scaleViewToActualSize(view);
        isViewScaled = view.getAttributeNS(null,
else if (self.scaleToFitOnDoubleClick) {
        self.scaleViewToFit(view);
else if (self.actualSizeOnDoubleClick) {
self.scaleViewToFit = function(view) {
        return self.setViewScaleValue(view, true);
self.scaleViewToActualSize = function(view) {
        self.setViewScaleValue(view, false, 1);
self.onloadHandler = function(event) {
}
}
}
self.initialize();
self.setElementHTML = function(id, value) {
        var element = self.getElement(id);
}
element.innerHTML = value;
self.getStackArray = function(error) {
        var value = "";
        if (error==null) {
try {
                 error = new Error("Stack");
          catch (e) {
} }
}

(value, index, array) {
value = value.replace(/\@.*/,"");
if ("stack" in error) {
  value = error.stack;
  var methods = value.split(/\n/g);
  var newArray = methods ? methods.map(function
                          return value;
                  }) : null;
                  if (newArray &&
newArray[0].includes("getStackTrace")) {
}
newArray.shift();
                  if (newArray &&
newArray[0].includes("getStackArray")) {
                         newArray.shift();
                  if (newArray && newArray[0]=="") {
                         newArray.shift();
                        return newArray;
                }
                return null;
        }
        self.log = function(value) {
}
console.log.apply(this, [value]);
}
}
        // initialize on load
        // sometimes the body size is 0 so we call this now and again
later
        window.addEventListener("load", self.onloadHandler);
        window.document.addEventListener("DOMContentLoaded",
self.onloadHandler);
}
window.application = new Application();
</script>
</head>
<body>
<div id="About_Landing">
        <div id="I_am_passionate_about_making_b">
                <span>I am passionate about making beautiful and
meaningful things. My goal as a UX Engineer is to create seamless
usability in the design of a product or feature from start to finish.
My career has evolved from a curious journalism student to a UX
Engineer at a leading global auto company. <br/><br/>Currently I am
working as a UX Engineer remotely for General Motors. </span>
        </div>
        <div id="Group_8">
                <svg class="Rectangle_19">
                        <rect id="Rectangle_19" rx="0" ry="0" x="0"
y="0" width="795" height="45">

                        </rect>
                </svg>
                <div id="_Maeve__Tierney__UX_Engineer_w">
                        <span></span><br><span style="font-
family:Times New Roman;font-style:italic;font-weight:normal;font-
size:160px;">Maeve <br/>Tierney /</span><span style="font-
family:Raleway;font-style:normal;font-weight:bold;font-size:160px;">
</span><span style="font-family:Roboto;font-style:normal;font-
weight:lighter;font-size:60px;letter-spacing:1px;text-
decoration:underline;">UX Engineer who Codes</span>
                </div>
        </div>
        <div id="global_nav_-_about" class="global_nav___about">
                <svg class="Rectangle_35">
                        <rect id="Rectangle_35" rx="0" ry="0" x="0"
y="0" width="1920" height="156">
                        </rect>
                </svg>
                <div id="Group_89">
                        <div id="Group_10">
                                <div id="Group_9">
                                        <div id="Group_3">
                                                <div id="About">
 <span>About</span>
onclick="application.goToTargetView(event)" id="Contact_Me">
Me</span>
onclick="application.goToTargetView(event)" id="Work">
<span>Contact
<span>Work</span>
onclick="application.goToTargetView(event)" id="Resume">
<span>Resume</span>
                </div>
        </div>
        </div>
</div>
        </div>
</div>
<div id="Group_13">
        <div id="Group_6">
class="Icon_feather_linkedin">
19.5">
<svg class="Path_3" viewBox="15 12 18
<div id="Icon_feather-linkedin"
                                        <path id="Path_3" d="M 24 12 C
28.97056198120117 12 33 16.02943801879883 33 21 L 33 31.5 L 27 31.5 L
27 21 C 27 19.3431453704834 25.6568546295166 18 24 18 C
22.3431453704834 18 21 19.3431453704834 21 21 L 21 31.5 L 15 31.5 L 15
21 C 15 16.02943801879883 19.02943801879883 11.99999904632568
</div> <div
</div> <div
</div> <div

24.00000190734863 12 Z">
        </path>
</svg>
<svg class="Path_4" viewBox="3 13.5 6
 18">
L 9 13.5 L 9 31.5 L 3 31.5 L 3 13.5 Z">
<path id="Path_4" d="M 3 13.5
                                        </path>
                                </svg>
                                <svg class="Path_5" viewBox="3 3 6 6">
                                        <path id="Path_5" d="M 9 6 C 9
7.656854629516602 7.656854152679443 9 6 9 C 4.343146324157715 9
3.000000476837158 7.656854629516602 3 6.000000476837158 C 3
4.343145370483398 4.343146324157715 2.999999523162842
6.000000476837158 3 C 7.656854629516602 3 9 4.343146324157715 9
6.000000476837158 Z">
24">
                </path>
        </svg>
</div>
<div id="Icon_feather-mail">
        <svg class="Path_6" viewBox="3 6 30
                                        <path id="Path_6" d="M 6 6 L
30 6 C 31.64999961853027 6 33 7.349999904632568 33 9 L 33 27 C 33
28.64999961853027 31.64999961853027 30 30 30 L 6 30 C
4.349999904632568 30 3 28.64999961853027 3 27 L 3 9 C 3
7.349999904632568 4.349999904632568 6 6 6 Z">
10.5">
18 19.5 L 3 9">
27 9">
                </path>
        </svg>
        <svg class="Path_7" viewBox="3 9 30
                <path id="Path_7" d="M 33 9 L
                </path>
        </svg>
</div>
<div id="Icon_feather-download">
        <svg class="Path_8" viewBox="4.5 22.5
                                        <path id="Path_8" d="M 31.5
22.5 L 31.5 28.5 C 31.5 30.1568546295166 30.1568546295166 31.5 28.5
31.5 L 7.5 31.5 C 5.843146324157715 31.5 4.500000476837158
30.1568546295166 4.5 28.5 L 4.5 22.5">
15 7.5">
L 18 22.5 L 25.5 15">
1.5 18">
22.5 L 18 4.5">
        </path>
</svg>
<svg class="Path_9" viewBox="10.5 15
        <path id="Path_9" d="M 10.5 15
        </path>
</svg>
<svg class="Path_10" viewBox="18 4.5
        <path id="Path_10" d="M 18
        </path>
</svg>

         </div>
</div>
</body>
</html>
        </div>
</div>
